#!/usr/bin/env python
# -*- coding: utf-8 -*-

import Tables

import os
import glob
import logging
import datetime
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker

###############################################################################
# Plist reader:

import plistlib

class DiagnosticLoader:
	def __init__(self, _session, _dirName):
		self.__session = _session
		self.__launch = Tables.Launch( time = datetime.datetime.now(), name = _dirName )
		self.__session.add( self.__launch )
		self.__session.commit()

	def getOrCreate(self, _table, **_kwargs):
	    instance = self.__session.query(_table).filter_by(**_kwargs).first()
	    if instance:
	        return instance, False
	    else:
	        instance = _table(**_kwargs)
	        self.__session.add(instance)
	        return instance, True

	def load( self, _plistFileName ):
		with open(_plistFileName, 'rb') as fp:
			plist = plistlib.readPlist(fp)
			self.createDiagnosticsFromDict( plist )

	def getFile( self, _fileName ):
		return self.getOrCreate( Tables.File, name = _fileName )[0]

	def createPath( self, _fileNames, _plist):
		pieceId = 0
		for piecePl in _plist:
			if piecePl['kind'] != 'event':
				continue
			pathPiece, created = self.getOrCreate(Tables.PathPiece, 
			    message             = piecePl['message'],
			    extended_message    = piecePl['extended_message'],
			    depth               = piecePl['depth'],
			    piece_id            = pieceId,
			    line                = piecePl['location']['line'],
			    col                 = piecePl['location']['col'],
			    file                = self.getFile( _fileNames[ piecePl['location']['file'] ] )	
			)
			pieceId = pieceId + 1
			pathPiece.launches.append( self.__launch )
			yield pathPiece, created



	def createDiagnosticsFromDict( self, _plist ):
		fileNames = _plist[ 'files' ]
		diagnosticsPl = _plist[ 'diagnostics' ]
		# TODO revise all possible attributes in plist file.

		for diagPl in diagnosticsPl:
			uniqueId = diagPl['issue_hash']
			diag, created = self.getOrCreate( Tables.Diagnostic, issue_hash = uniqueId )
			if created:
				diag.description        		= diagPl['description']
				diag.category           		= diagPl['category']
				diag.type               		= diagPl['type']
				diag.issue_context_kind 		= diagPl['issue_context_kind']
				diag.issue_context   			= diagPl['issue_context']  
				diag.issue_hash					= diagPl['issue_hash']                     
				diag.line               		= diagPl['location']['line']
				diag.col                		= diagPl['location']['col']
				diag.file              			= self.getFile( fileNames[ diagPl['location']['file'] ] )
			
			diag.launches.append( self.__launch  )
			for piece, peaceCreated in self.createPath( fileNames, diagPl['path'] ):
				if peaceCreated:
					diag.all_path_pieces.append( piece )
			# TODO: Maybe autorefreshing would be better?
			self.__session.commit()


###############################################################################
# Command executors:

class DatabaseAccessProblem( BaseException ):
	pass

class NoInitializedDatabase( DatabaseAccessProblem ):
	pass

class CommandExecutor(object):
	def __init__( self, _containingDir ):
		self.__dbContainingDir = os.path.abspath( _containingDir )
		self.__dbPath = self.__dbContainingDir + '/' + self.getDatabaseName()
		self.__engine = None

	def getDatabaseName( self ):
		#return ".tracking-platform.db"
		return "tp_db.sqlite" 
	def getDBContainingDir( self ):
		return self.__dbContainingDir
	def getDBPath( self ):
		return self.__dbPath
	

	def checkDatabaseAvailability( self ):
		if not os.path.exists( self.getDBPath() ):
			raise NoInitializedDatabase()
		if not os.access( self.getDBPath(), os.W_OK ):
			raise DatabaseAccessProblem()
	def connect( self, _canBeNonexistent = False ):
		if not self.__engine:
			if not _canBeNonexistent:
				self.checkDatabaseAvailability()
			self.__engine = create_engine('sqlite:///' + self.getDBPath(), echo=False)
		Session = sessionmaker(bind=self.__engine)
		return Session()
	def getEngine( self ):
		if not self.__engine:
			raise RuntimeError()
		return self.__engine


	def execute( self ):
		pass

class AddCommandExecutor( CommandExecutor ):
	def __init__( self, **_args ):
		super( AddCommandExecutor, self ).__init__( os.getcwd() )
		self.__resultsDir = os.path.abspath( _args['result_dir'] )
		self.__loadManyLaunches = ( 'fewruns' in _args )

	def loadDiagnostics( self, _dir ):
		self.checkDatabaseAvailability()
		files = glob.glob( _dir + '/*.plist' )
		if not files:
			print( "WARNING: No plist files are presented in " + self.__resultsDir )

		session = self.connect()
		diagLoader = DiagnosticLoader( session, _dir )
		for file in files:
			diagLoader.load( file )

	def execute( self ):
		if not self.__loadManyLaunches:
			self.loadDiagnostics( self.__resultsDir )
			return

		for name in sorted( os.listdir(self.__resultsDir) ):
			absPath = os.path.join(self.__resultsDir, name)
			if os.path.isdir(absPath):
				self.loadDiagnostics( absPath )
				print "Added diagnostics from " + absPath



class InitializeCommandExecutor( CommandExecutor ):
	def __init__( self, **_args ):
		super( InitializeCommandExecutor, self ).__init__( _args['dest_dir'] )
		
		self.__printSuccessMessage = True
		if 'print_success_message' in _args:
			self.__printSuccessMessage = _args['print_success_message']

	def execute( self ):
		if not os.path.exists( self.getDBContainingDir() ):
			try:
				os.makedirs( self.getDBContainingDir() )
			except os.error:
				raise DatabaseAccessProblem()

		if os.path.exists( self.getDBPath() ):
			print( "ERROR: Database is already intialized at " + self.getDBPath() )
			return

		self.connect(_canBeNonexistent = True)
		Tables.initializeTables( self.getEngine() )

		if self.__printSuccessMessage:
			print( "Database has been successfully initialized at " + self.getDBPath() )


class CleanCommandExecutor( CommandExecutor ):
	def __init__( self, **_args ):
		super( CleanCommandExecutor, self ).__init__( os.getcwd() )
		self.__dontCreate = 'remove' in _args
	def execute( self ):
		if not os.path.exists( self.getDBPath() ):
			return
		self.checkDatabaseAvailability()
		try:
			os.remove( self.getDBPath() )
		except os.error:
			raise DatabaseAccessProblem()

		if not self.__dontCreate:
			InitializeCommandExecutor( dest_dir=self.getDBContainingDir(), print_success_message = False ).execute()
		print( "Database has been cleaned successfully.")


class LogCommandExecutor( CommandExecutor ):
	def __init__( self, **_args ):
		super( LogCommandExecutor, self ).__init__( os.getcwd() )
	
	def getIndent( self ):
		return '\t'

	def showDifference( self, _oldLaunch, _newLaunch ):
		newDiagnostics 	= set( _newLaunch.diagnostics )
		oldDiagnostics 	= set( _oldLaunch.diagnostics )
		fixed 			= oldDiagnostics.difference( newDiagnostics )
		notFixed 		= newDiagnostics.intersection( oldDiagnostics )
		new				= newDiagnostics.difference( oldDiagnostics )
		print (self.getIndent() + "Fixed: " 	+ str( len( fixed )) 	) 
		print (self.getIndent() + "Not fixed: " + str( len( notFixed )) ) 
		print (self.getIndent() + "New: " 		+ str( len( new )) 		) 

	def execute( self ):
		session = self.connect()
		newLaunch = None
		oldLaunch = None
		for launch in reversed( session.query( Tables.Launch ).all() ):
			newLaunch = oldLaunch
			oldLaunch = launch
			if newLaunch:
				self.showDifference(oldLaunch, newLaunch)
				print "\n"
			print "################################################################"
			print launch


class ShowCommandExecutor( CommandExecutor ):
	def __init__( self, **_args ):
		super( ShowCommandExecutor, self ).__init__( os.getcwd() )
		self.__n = _args[ 'n' ]
	def execute( self ):
		session = self.connect()
		launch = session.query( Tables.Launch ).filter( Tables.Launch.id == self.__n ).one()
		print launch
		print "################################################################"
		for diag in launch.diagnostics:
			print "\n",
			print diag
			print "################################################################"

	
###############################################################################
# Entry point:

def main():

	import argparse
	top_parser = argparse.ArgumentParser(description="Tracking platform")
	top_parser.add_argument('--version', action='version', version='Tracking Platform 0.1')
	subparsers = top_parser.add_subparsers(help='sub-command help')
	
	# initialize command
	parser_initialize = subparsers.add_parser(
		'init', 
		description="Initializes database", 
		help='Initializes database in a current directory.')
	parser_initialize.set_defaults(executor=InitializeCommandExecutor)
	parser_initialize.add_argument('dest_dir', help="Directory where database will be placed.", nargs = '?', default = '.')


	# add command
	parser_add = subparsers.add_parser(
		'add', 
		description="Adds results to database", 
		help="Adds scan-build's results to the database.")
	parser_add.set_defaults(executor=AddCommandExecutor)
	parser_add.add_argument('--few-runs', dest = 'fewruns', action='store_true', help="Assumes directory containing a few scan-build's runs and adds all of them.")
	parser_add.add_argument('result_dir', help="Directory which was produced by one scan-build's run.")


	# clean command
	parser_clean = subparsers.add_parser(
		'clean', 
		description="Cleans the database", 
		help="Completely cleans the database")
	parser_clean.set_defaults(executor=CleanCommandExecutor)
	parser_clean.add_argument('--remove', dest = 'remove', action='store_true', help="Removes database file completely.")

	# log command
	parser_log = subparsers.add_parser(
		'log', 
		description="Shows list of scan-build's runs", 
		help="Shows list of all scan-build's runs that have been added to the database.")
	parser_log.set_defaults(executor=LogCommandExecutor)


	# show command
	parser_show = subparsers.add_parser(
		'show', 
		description="Shows list of diagnostics", 
		help="Shows all diagnostics for specified number of scan-build's run.")
	parser_show.set_defaults(executor=ShowCommandExecutor)
	parser_show.add_argument('n', type=int, help="Directory which was produced by one scan-build's run.")
	

	# parse command line arguments
	given_args = top_parser.parse_args()
	commandExecutor = given_args.executor(**vars( given_args ) )
	try:
		commandExecutor.execute()
	except NoInitializedDatabase:
		print( "ERROR: No initialized database in the current directory. Do 'tracking-platform init' before.")
	except DatabaseAccessProblem:
		print( "ERROR: Problem with accessing database." ) 

if __name__ == '__main__':
	main()